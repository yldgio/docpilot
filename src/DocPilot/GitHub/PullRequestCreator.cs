using DocPilot.Configuration;
using DocPilot.Heuristics;
using LibGit2Sharp;

namespace DocPilot.GitHub;

public sealed class PullRequestCreator
{
    private readonly GitHubService _github;
    private readonly string _repositoryPath;
    private readonly DocPilotConfig _config;

    public PullRequestCreator(string repositoryPath, DocPilotConfig config)
    {
        _repositoryPath = repositoryPath;
        _config = config;

        using var repo = new Repository(repositoryPath);
        var remote = repo.Network.Remotes["origin"];
        if (remote is null)
        {
            throw new InvalidOperationException("No 'origin' remote found in repository");
        }

        var (owner, repoName) = GitHubService.ParseRemoteUrl(remote.Url);
        _github = new GitHubService(owner, repoName);
    }

    public async Task<PrCreationResult> CreateDocumentationPrAsync(
        MappingResult mapping,
        IReadOnlyList<string> changedFiles,
        PrOptions options,
        CancellationToken cancellationToken = default)
    {
        var branchName = GenerateBranchName(mapping);
        var prTitle = options.Title ?? GeneratePrTitle(mapping);
        var prBody = GeneratePrBody(mapping, changedFiles);
        var labels = DetermineLabels(mapping);
        var isDraft = options.Draft || mapping.OverallConfidence == ConfidenceLevel.Low;

        try
        {
            // Create branch
            var baseBranch = options.TargetBranch ?? GetDefaultBranch();
            var branch = await _github.CreateBranchAsync(branchName, baseBranch, cancellationToken);

            // Read and commit changed files
            var fileChanges = changedFiles.Select(path =>
            {
                var fullPath = Path.Combine(_repositoryPath, path);
                var content = File.ReadAllText(fullPath);
                return new FileChange
                {
                    Path = path,
                    Content = content
                };
            }).ToList();

            var commitMessage = GenerateCommitMessage(mapping);
            var commit = await _github.CommitFilesAsync(branchName, fileChanges, commitMessage, cancellationToken);

            // Create PR
            var pr = await _github.CreatePullRequestAsync(
                prTitle,
                prBody,
                branchName,
                baseBranch,
                isDraft,
                labels,
                cancellationToken);

            return new PrCreationResult
            {
                Success = true,
                PullRequest = pr,
                Branch = branch,
                Commit = commit
            };
        }
        catch (Exception ex)
        {
            return new PrCreationResult
            {
                Success = false,
                Error = ex.Message
            };
        }
    }

    private string GenerateBranchName(MappingResult mapping)
    {
        var timestamp = DateTime.UtcNow.ToString("yyyyMMddHHmmss");
        var context = mapping.OverallChangeType.ToString().ToLowerInvariant();
        return $"docpilot/{context}-{timestamp}";
    }

    private string GeneratePrTitle(MappingResult mapping)
    {
        var emoji = mapping.OverallChangeType switch
        {
            ChangeType.Feature => "‚ú®",
            ChangeType.Bugfix => "üêõ",
            ChangeType.Refactor => "‚ôªÔ∏è",
            ChangeType.Breaking => "üìö",
            _ => "üìù"
        };

        var action = mapping.Targets.Count switch
        {
            1 => $"Update {Path.GetFileName(mapping.Targets[0].FilePath)}",
            _ => $"Update {mapping.Targets.Count} documentation files"
        };

        return $"{emoji} docs: {action}";
    }

    private string GeneratePrBody(MappingResult mapping, IReadOnlyList<string> changedFiles)
    {
        var sb = new System.Text.StringBuilder();

        sb.AppendLine("## üìù Documentation Update");
        sb.AppendLine();
        sb.AppendLine("This PR was automatically generated by **DocPilot** to keep documentation in sync with code changes.");
        sb.AppendLine();
        sb.AppendLine("### Summary");
        sb.AppendLine();
        sb.AppendLine($"- **Change Type:** {mapping.OverallChangeType}");
        sb.AppendLine($"- **Confidence:** {mapping.OverallConfidence} ({mapping.AverageConfidence:P0})");
        sb.AppendLine($"- **Files Updated:** {changedFiles.Count}");
        sb.AppendLine();
        sb.AppendLine("### Changes");
        sb.AppendLine();

        foreach (var file in changedFiles)
        {
            sb.AppendLine($"- `{file}`");
        }

        sb.AppendLine();
        sb.AppendLine("### Affected Documentation Targets");
        sb.AppendLine();

        foreach (var target in mapping.Targets)
        {
            sb.AppendLine($"#### {target.FilePath}");
            sb.AppendLine();
            if (!string.IsNullOrEmpty(target.Section))
            {
                sb.AppendLine($"- **Section:** {target.Section}");
            }
            sb.AppendLine($"- **Confidence:** {target.Confidence} ({target.ConfidenceScore:P0})");
            sb.AppendLine($"- **Source Files:** {string.Join(", ", target.SourceFiles.Select(f => $"`{f}`"))}");
            sb.AppendLine();
        }

        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("*Generated with ‚ù§Ô∏è by [DocPilot](https://github.com/your-org/docpilot)*");

        return sb.ToString();
    }

    private string GenerateCommitMessage(MappingResult mapping)
    {
        var scope = mapping.Targets.Count == 1
            ? Path.GetFileNameWithoutExtension(mapping.Targets[0].FilePath)
            : "multiple";

        return $"docs({scope}): update documentation for {mapping.OverallChangeType.ToString().ToLowerInvariant()} changes";
    }

    private List<string> DetermineLabels(MappingResult mapping)
    {
        var labels = new List<string> { "documentation", "docpilot" };

        labels.Add(mapping.OverallConfidence switch
        {
            ConfidenceLevel.High => "ready-for-review",
            ConfidenceLevel.Medium => "needs-review",
            ConfidenceLevel.Low => "draft",
            _ => "needs-review"
        });

        return labels;
    }

    private string GetDefaultBranch()
    {
        using var repo = new Repository(_repositoryPath);
        return repo.Head.FriendlyName.Contains("main") ? "main" : "master";
    }
}

public sealed record PrOptions
{
    public string? Title { get; init; }
    public string? TargetBranch { get; init; }
    public bool Draft { get; init; }
}

public sealed record PrCreationResult
{
    public required bool Success { get; init; }
    public string? Error { get; init; }
    public PullRequestReference? PullRequest { get; init; }
    public BranchReference? Branch { get; init; }
    public CommitReference? Commit { get; init; }
}
